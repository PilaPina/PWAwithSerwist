import type { Serwist } from "../../Serwist.js";
import type { HandlerDidErrorCallbackParam, SerwistPlugin } from "../../types.js";
export interface PrecacheFallbackEntry {
    /**
     * A function that checks whether the fallback entry can be used
     * for a request.
     */
    matcher: (param: HandlerDidErrorCallbackParam) => boolean;
    /**
     * A precached URL to be used as a fallback.
     */
    url: string;
}
export interface PrecacheFallbackPluginOptions {
    /**
     * Precached URLs to be used as the fallback
     * if the associated strategy can't generate a response.
     */
    fallbackUrls: (string | PrecacheFallbackEntry)[];
    /**
     * Your `Serwist` instance.
     */
    serwist: Serwist;
}
/**
 * `PrecacheFallbackPlugin` allows you to specify offline fallbacks
 * to be used when a given strategy is unable to generate a response.
 *
 * It does this by intercepting the `handlerDidError` plugin callback
 * and returning a precached response, taking the expected revision parameter
 * into account automatically.
 */
export declare class PrecacheFallbackPlugin implements SerwistPlugin {
    private readonly _fallbackUrls;
    private readonly _serwist;
    /**
     * Constructs a new `PrecacheFallbackPlugin` with the associated `fallbackUrls`.
     *
     * @param config
     */
    constructor({ fallbackUrls, serwist }: PrecacheFallbackPluginOptions);
    /**
     * @returns The precache response for one of the fallback URLs, or `undefined` if
     * nothing satisfies the conditions.
     * @private
     */
    handlerDidError(param: HandlerDidErrorCallbackParam): Promise<Response | undefined>;
}
//# sourceMappingURL=PrecacheFallbackPlugin.d.ts.map