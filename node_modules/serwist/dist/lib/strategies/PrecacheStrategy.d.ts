import type { SerwistPlugin } from "../../types.js";
import type { StrategyOptions } from "./Strategy.js";
import { Strategy } from "./Strategy.js";
import type { StrategyHandler } from "./StrategyHandler.js";
interface PrecacheStrategyOptions extends StrategyOptions {
    /**
     * Whether to attempt to get the response from the network
     * if there's a precache miss.
     */
    fallbackToNetwork?: boolean;
}
/**
 * A `serwist/strategies.Strategy` implementation
 * specifically designed to both cache and fetch precached assets.
 *
 * Note: an instance of this class is created automatically when creating a
 * `Serwist` instance; it's generally not necessary to create this yourself.
 */
export declare class PrecacheStrategy extends Strategy {
    private readonly _fallbackToNetwork;
    static readonly defaultPrecacheCacheabilityPlugin: SerwistPlugin;
    static readonly copyRedirectedCacheableResponsesPlugin: SerwistPlugin;
    /**
     * @param options
     */
    constructor(options?: PrecacheStrategyOptions);
    /**
     * @private
     * @param request A request to run this strategy for.
     * @param handler The event that triggered the request.
     * @returns
     */
    _handle(request: Request, handler: StrategyHandler): Promise<Response>;
    _handleFetch(request: Request, handler: StrategyHandler): Promise<Response>;
    _handleInstall(request: Request, handler: StrategyHandler): Promise<Response>;
    /**
     * This method is complex, as there a number of things to account for:
     *
     * The `plugins` array can be set at construction, and/or it might be added to
     * to at any time before the strategy is used.
     *
     * At the time the strategy is used (i.e. during an `install` event), there
     * needs to be at least one plugin that implements `cacheWillUpdate` in the
     * array, other than `copyRedirectedCacheableResponsesPlugin`.
     *
     * - If this method is called and there are no suitable `cacheWillUpdate`
     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
     *
     * - If this method is called and there is exactly one `cacheWillUpdate`, then
     * we don't have to do anything (this might be a previously added
     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
     *
     * - If this method is called and there is more than one `cacheWillUpdate`,
     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
     * we need to remove it. (This situation is unlikely, but it could happen if
     * the strategy is used multiple times, the first without a `cacheWillUpdate`,
     * and then later on after manually adding a custom `cacheWillUpdate`.)
     *
     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
     *
     * @private
     */
    _useDefaultCacheabilityPluginIfNeeded(): void;
}
export {};
//# sourceMappingURL=PrecacheStrategy.d.ts.map