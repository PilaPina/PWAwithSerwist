import type { HandlerCallbackOptions, RouteHandlerObject, SerwistPlugin } from "../../types.js";
import { StrategyHandler } from "./StrategyHandler.js";
export interface StrategyOptions {
    /**
     * Cache name to store and retrieve requests. Defaults to Serwist's default cache names.
     */
    cacheName?: string;
    /**
     * [Plugins](https://serwist.pages.dev/docs/serwist/runtime-caching/plugins) to use in conjunction with this caching strategy.
     */
    plugins?: SerwistPlugin[];
    /**
     * Options passed to [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796) `fetch()` calls made by
     * this strategy.
     */
    fetchOptions?: RequestInit;
    /**
     * The [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     * passed to any `cache.match()` or `cache.put()` call made by this strategy.
     */
    matchOptions?: CacheQueryOptions;
}
/**
 * Abstract class for implementing runtime caching strategies.
 *
 * Custom strategies should extend this class and leverage `StrategyHandler`, which will ensure all relevant cache options,
 * fetch options, and plugins are used (per the current strategy instance), to perform all fetching and caching logic.
 */
export declare abstract class Strategy implements RouteHandlerObject {
    cacheName: string;
    plugins: SerwistPlugin[];
    fetchOptions?: RequestInit;
    matchOptions?: CacheQueryOptions;
    protected abstract _handle(request: Request, handler: StrategyHandler): Promise<Response | undefined>;
    /**
     * Creates a new instance of the strategy and sets all documented option
     * properties as public instance properties.
     *
     * Note: if a custom strategy class extends the base Strategy class and does
     * not need more than these properties, it does not need to define its own
     * constructor.
     *
     * @param options
     */
    constructor(options?: StrategyOptions);
    /**
     * Performs a request strategy and returns a `Promise` that will resolve with
     * a `Response`, invoking all relevant plugin callbacks.
     *
     * When a strategy instance is registered with a `Route`, this method is automatically
     * called when the route matches.
     *
     * Alternatively, this method can be used in a standalone `FetchEvent`
     * listener by passing it to `event.respondWith()`.
     *
     * @param options A `FetchEvent` or an object with the properties listed below.
     * @param options.request A request to run this strategy for.
     * @param options.event The event associated with the request.
     * @param options.url
     * @param options.params
     */
    handle(options: FetchEvent | HandlerCallbackOptions): Promise<Response>;
    /**
     * Similar to `handle()`, but instead of just returning a `Promise` that
     * resolves to a `Response`, it will return an tuple of `[response, done]` promises,
     * where `response` is equivalent to what `handle()` returns, and `done` is a
     * `Promise` that will resolve once all promises added to `event.waitUntil()` as a part
     * of performing the strategy have completed.
     *
     * You can await the `done` promise to ensure any extra work performed by
     * the strategy (usually caching responses) completes successfully.
     *
     * @param options A `FetchEvent` or `HandlerCallbackOptions` object.
     * @returns A tuple of [response, done] promises that can be used to determine when the response resolves as
     * well as when the handler has completed all its work.
     */
    handleAll(options: FetchEvent | HandlerCallbackOptions): [Promise<Response>, Promise<void>];
    _getResponse(handler: StrategyHandler, request: Request, event: ExtendableEvent): Promise<Response>;
    _awaitComplete(responseDone: Promise<Response>, handler: StrategyHandler, request: Request, event: ExtendableEvent): Promise<void>;
}
//# sourceMappingURL=Strategy.d.ts.map