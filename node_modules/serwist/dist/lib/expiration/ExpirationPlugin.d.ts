import type { CacheDidUpdateCallbackParam, CachedResponseWillBeUsedCallbackParam, SerwistPlugin } from "../../types.js";
export interface ExpirationPluginOptions {
    /**
     * The maximum number of entries to cache. Entries used the least will be removed
     * as the maximum is reached.
     */
    maxEntries?: number;
    /**
     * The maximum number of seconds before an entry is treated as stale and removed.
     */
    maxAgeSeconds?: number;
    /**
     * Determines whether `maxAgeSeconds` should be calculated from when an
     * entry was last fetched or when it was last used.
     *
     * @default "last-fetched"
     */
    maxAgeFrom?: "last-fetched" | "last-used";
    /**
     * The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
     * that will be used when calling `delete()` on the cache.
     */
    matchOptions?: CacheQueryOptions;
    /**
     * Whether to opt this cache into automatic deletion if the available storage quota has been exceeded.
     */
    purgeOnQuotaError?: boolean;
}
/**
 * This plugin can be used in a `serwist/strategies` Strategy to regularly enforce a
 * limit on the age and/or the number of cached requests.
 *
 * It can only be used with Strategy instances that have a custom `cacheName` property set.
 * In other words, it can't be used to expire entries in strategies that use the default runtime
 * cache name.
 *
 * Whenever a cached response is used or updated, this plugin will look
 * at the associated cache and remove any old or extra responses.
 *
 * When using `maxAgeSeconds`, responses may be used *once* after expiring
 * because the expiration clean up will not have occurred until *after* the
 * cached response has been used. If the response has a "Date" header, then a lightweight expiration
 * check is performed, and the response will not be used immediately.
 *
 * When using `maxEntries`, the least recently requested entry will be removed
 * from the cache.
 *
 * @see https://serwist.pages.dev/docs/serwist/runtime-caching/plugins/expiration-plugin
 */
export declare class ExpirationPlugin implements SerwistPlugin {
    private readonly _config;
    private _cacheExpirations;
    /**
     * @param config
     */
    constructor(config?: ExpirationPluginOptions);
    /**
     * A simple helper method to return a CacheExpiration instance for a given
     * cache name.
     *
     * @param cacheName
     * @returns
     * @private
     */
    private _getCacheExpiration;
    /**
     * A "lifecycle" callback that will be triggered automatically by the
     * `serwist/strategies` handlers when a `Response` is about to be returned
     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
     * the handler. It allows the `Response` to be inspected for freshness and
     * prevents it from being used if the `Response`'s `Date` header value is
     * older than the configured `maxAgeSeconds`.
     *
     * @param options
     * @returns `cachedResponse` if it is fresh and `null` if it is stale or
     * not available.
     * @private
     */
    cachedResponseWillBeUsed({ event, cacheName, request, cachedResponse }: CachedResponseWillBeUsedCallbackParam): Response | null;
    /**
     * @param cachedResponse
     * @returns
     * @private
     */
    private _isResponseDateFresh;
    /**
     * Extracts the `Date` header and parse it into an useful value.
     *
     * @param cachedResponse
     * @returns
     * @private
     */
    private _getDateHeaderTimestamp;
    /**
     * A "lifecycle" callback that will be triggered automatically by the
     * `serwist/strategies` handlers when an entry is added to a cache.
     *
     * @param options
     * @private
     */
    cacheDidUpdate({ cacheName, request }: CacheDidUpdateCallbackParam): Promise<void>;
    /**
     * Deletes the underlying `Cache` instance associated with this instance and the metadata
     * from IndexedDB used to keep track of expiration details for each `Cache` instance.
     *
     * When using cache expiration, calling this method is preferable to calling
     * `caches.delete()` directly, since this will ensure that the IndexedDB
     * metadata is also cleanly removed and that open IndexedDB instances are deleted.
     *
     * Note that if you're *not* using cache expiration for a given cache, calling
     * `caches.delete()` and passing in the cache's name should be sufficient.
     * There is no Serwist-specific method needed for cleanup in that case.
     */
    deleteCacheAndMetadata(): Promise<void>;
}
//# sourceMappingURL=ExpirationPlugin.d.ts.map