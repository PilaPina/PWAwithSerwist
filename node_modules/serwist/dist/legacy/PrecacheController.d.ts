import type { Strategy } from "../lib/strategies/Strategy.js";
import type { RouteHandlerCallback, SerwistPlugin } from "../types.js";
import type { CleanupResult, InstallResult, PrecacheEntry } from "../types.js";
interface PrecacheControllerOptions {
    /**
     * The cache to use for precaching.
     */
    cacheName?: string;
    /**
     * Plugins to use when precaching as well as responding to fetch
     * events for precached assets.
     */
    plugins?: SerwistPlugin[];
    /**
     * Whether to attempt to get the response from the network if there's
     * a precache miss.
     */
    fallbackToNetwork?: boolean;
    /**
     * The number of precache requests that should be made concurrently.
     *
     * @default 1
     */
    concurrentPrecaching?: number;
}
/**
 * Performs efficient precaching of assets.
 * @deprecated
 */
export declare class PrecacheController {
    private _installAndActiveListenersAdded?;
    private _concurrentPrecaching;
    private readonly _strategy;
    private readonly _urlsToCacheKeys;
    private readonly _urlsToCacheModes;
    private readonly _cacheKeysToIntegrities;
    /**
     * Create a new PrecacheController.
     *
     * @param options
     */
    constructor({ cacheName, plugins, fallbackToNetwork, concurrentPrecaching }?: PrecacheControllerOptions);
    /**
     * The strategy created by this controller and
     * used to cache assets and respond to fetch events.
     */
    get strategy(): Strategy;
    /**
     * Adds items to the precache list, removing any duplicates and
     * stores the files in the precache cache when the service
     * worker installs.
     *
     * This method can be called multiple times.
     *
     * @param entries Array of entries to precache.
     */
    precache(entries: (PrecacheEntry | string)[]): void;
    /**
     * This method will add items to the precache list, removing duplicates
     * and ensuring the information is valid.
     *
     * @param entries Array of entries to precache.
     */
    addToCacheList(entries: (PrecacheEntry | string)[]): void;
    /**
     * Precaches new and updated assets. Call this method from the service worker
     * install event.
     *
     * Note: this method calls `event.waitUntil()` for you, so you do not need
     * to call it yourself in your event handlers.
     *
     * @param event
     * @returns
     */
    install(event: ExtendableEvent): Promise<InstallResult>;
    /**
     * Deletes assets that are no longer present in the current precache manifest.
     * Call this method from the service worker activate event.
     *
     * Note: this method calls `event.waitUntil()` for you, so you do not need
     * to call it yourself in your event handlers.
     *
     * @param event
     * @returns
     */
    activate(event: ExtendableEvent): Promise<CleanupResult>;
    /**
     * Returns a mapping of a precached URL to the corresponding cache key, taking
     * into account the revision information for the URL.
     *
     * @returns A URL to cache key mapping.
     */
    getURLsToCacheKeys(): Map<string, string>;
    /**
     * Returns a list of all the URLs that have been precached by the current
     * service worker.
     *
     * @returns The precached URLs.
     */
    getCachedURLs(): string[];
    /**
     * Returns the cache key used for storing a given URL. If that URL is
     * unversioned, like `/index.html', then the cache key will be the original
     * URL with a search parameter appended to it.
     *
     * @param url A URL whose cache key you want to look up.
     * @returns The versioned URL that corresponds to a cache key
     * for the original URL, or undefined if that URL isn't precached.
     */
    getCacheKeyForURL(url: string): string | undefined;
    /**
     * @param url A cache key whose SRI you want to look up.
     * @returns The subresource integrity associated with the cache key,
     * or undefined if it's not set.
     */
    getIntegrityForCacheKey(cacheKey: string): string | undefined;
    /**
     * This acts as a drop-in replacement for
     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
     * with the following differences:
     *
     * - It knows what the name of the precache is, and only checks in that cache.
     * - It allows you to pass in an "original" URL without versioning parameters,
     * and it will automatically look up the correct cache key for the currently
     * active revision of that URL.
     *
     * E.g., `matchPrecache('index.html')` will find the correct precached
     * response for the currently active service worker, even if the actual cache
     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
     *
     * @param request The key (without revisioning parameters)
     * to look up in the precache.
     * @returns
     */
    matchPrecache(request: string | Request): Promise<Response | undefined>;
    /**
     * Returns a function that looks up `url` in the precache (taking into
     * account revision information), and returns the corresponding `Response`.
     *
     * @param url The precached URL which will be used to lookup the response.
     * @return
     */
    createHandlerBoundToURL(url: string): RouteHandlerCallback;
}
export {};
//# sourceMappingURL=PrecacheController.d.ts.map