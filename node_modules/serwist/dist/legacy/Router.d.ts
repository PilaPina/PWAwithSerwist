import type { Route } from "../Route.js";
import type { HTTPMethod } from "../constants.js";
import type { RouteHandler, RouteHandlerCallbackOptions, RouteMatchCallback, RouteMatchCallbackOptions } from "../types.js";
/**
 * `Router` can be used to process a `FetchEvent` using one or more `Route`(s), responding with a `Response`
 * if a matching route exists.
 *
 * If no `Route` matches given a `Request`, the `Router` will use the default handler if one is defined.
 *
 * Should the matching Route throw an error, the Router will use the catch handler if one is defined to
 * gracefully deal with issues and respond with a `Request`.
 *
 * If a `Request` matches multiple routes, the earliest registered route will be used to respond to the `Request`.
 * @deprecated
 */
export declare class Router {
    private readonly _routes;
    private readonly _defaultHandlerMap;
    private _fetchListenerHandler;
    private _cacheListenerHandler;
    private _catchHandler?;
    /**
     * Initializes a new Router.
     */
    constructor();
    /**
     * @returns routes A `Map` of HTTP method name (`'GET'`, etc.) to an array of all the corresponding `Route`
     * instances that are registered.
     */
    get routes(): Map<HTTPMethod, Route[]>;
    /**
     * Adds a `fetch` event listener to respond to events when a `Route` matches
     * the event's request. Effectively no-op if `addFEtchListener` has been
     * called, but `removeFetchListener` has not.
     */
    addFetchListener(): void;
    /**
     * Removes `fetch` event listener added by `addFetchListener`.
     * Effectively no-op if either `addFetchListener` has not been called or,
     * if it has, so has `removeFetchListener`.
     */
    removeFetchListener(): void;
    /**
     * Adds a `message` event listener for URLs to cache from the window.
     * This is useful to cache resources loaded on the page prior to when the
     * service worker started controlling it. Effectively no-op if `addCacheListener`
     * has been called, but `removeCacheListener` hasn't.
     *
     * The format of the message data sent from the window should be as follows.
     * Where the `urlsToCache` array may consist of URL strings or an array of
     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
     *
     * ```
     * {
     *   type: 'CACHE_URLS',
     *   payload: {
     *     urlsToCache: [
     *       './script1.js',
     *       './script2.js',
     *       ['./script3.js', {mode: 'no-cors'}],
     *     ],
     *   },
     * }
     * ```
     */
    addCacheListener(): void;
    /**
     * Removes the `message` event listener added by `addCacheListener`.
     * Effectively no-op if either `addCacheListener` has not been called or,
     * if it has, so has `removeCacheListener`.
     */
    removeCacheListener(): void;
    /**
     * Apply the routing rules to a `FetchEvent` object to get a `Response` from an
     * appropriate `Route`'s handler.
     *
     * @param options
     * @returns A promise is returned if a registered route can handle the request.
     * If there is no matching route and there's no `defaultHandler`, `undefined`
     * is returned.
     */
    handleRequest({ request, event, }: {
        /**
         * The request to handle.
         */
        request: Request;
        /**
         * The event that triggered the request.
         */
        event: ExtendableEvent;
    }): Promise<Response> | undefined;
    /**
     * Checks a request and URL (and optionally an event) against the list of
     * registered routes, and if there's a match, returns the corresponding
     * route along with any params generated by the match.
     *
     * @param options
     * @returns An object with `route` and `params` properties. They are populated
     * if a matching route was found or `undefined` otherwise.
     */
    findMatchingRoute({ url, sameOrigin, request, event }: RouteMatchCallbackOptions): {
        route?: Route;
        params?: RouteHandlerCallbackOptions["params"];
    };
    /**
     * Define a default `handler` that's called when no routes explicitly
     * match the incoming request.
     *
     * Each HTTP method (`'GET'`, `'POST'`, etc.) gets its own default handler.
     *
     * Without a default handler, unmatched requests will go against the
     * network as if there were no service worker present.
     *
     * @param handler A callback function that returns a `Promise` resulting in a `Response`.
     * @param method The HTTP method to associate with this default handler. Each method
     * has its own default. Defaults to `'GET'`.
     */
    setDefaultHandler(handler: RouteHandler, method?: HTTPMethod): void;
    /**
     * If a `Route` throws an error while handling a request, this `handler`
     * will be called and given a chance to provide a response.
     *
     * @param handler A callback function that returns a Promise resulting
     * in a Response.
     */
    setCatchHandler(handler: RouteHandler): void;
    /**
     * Registers a `RegExp`, string, or function with a caching
     * strategy to the `Router`.
     *
     * @param capture If the capture param is a `Route`, all other arguments will be ignored.
     * @param handler A callback function that returns a `Promise` resulting in a `Response`.
     * This parameter is required if `capture` is not a `Route` object.
     * @param method The HTTP method to match the Route against. Defaults to `'GET'`.
     * @returns The generated `Route`.
     */
    registerCapture(capture: RegExp | string | RouteMatchCallback | Route, handler?: RouteHandler, method?: HTTPMethod): Route;
    /**
     * Registers a `Route` with the router.
     *
     * @param route The `Route` to register.
     */
    registerRoute(route: Route): void;
    /**
     * Unregisters a `Route` with the `Router`.
     *
     * @param route The `Route` to unregister.
     */
    unregisterRoute(route: Route): void;
}
//# sourceMappingURL=Router.d.ts.map