import type { PrecacheRouteOptions, RuntimeCaching } from "../types.js";
import type { PrecacheController } from "./PrecacheController.js";
import type { PrecacheFallbackEntry } from "./PrecacheFallbackPlugin.js";
import type { Router } from "./Router.js";
export interface FallbackEntry extends PrecacheFallbackEntry {
    /**
     * The revision used for precaching.
     */
    revision: string;
}
export interface FallbacksOptions {
    /**
     * A list of fallback entries.
     */
    entries: FallbackEntry[];
    /**
     * Precache options that will be used for your
     * fallback entries.
     */
    precacheOptions?: PrecacheRouteOptions;
}
export interface FallbacksOptions {
    /**
     * An optional `PrecacheController` instance. If not provided, the singleton
     * `PrecacheController` will be used.
     */
    precacheController?: PrecacheController;
    /**
     * An optional `Router` instance. If not provided, the singleton `Router`
     * will be used.
     */
    router?: Router;
    /**
     * Your previous list of caching strategies.
     */
    runtimeCaching: RuntimeCaching[];
    /**
     * A list of fallback entries.
     */
    entries: FallbackEntry[];
    /**
     * Precache options that will be used for your
     * fallback entries.
     */
    precacheOptions?: PrecacheRouteOptions;
}
/**
 * Precaches routes so that they can be used as a fallback when
 * a Strategy fails to generate a response.
 *
 * Note: This function mutates `runtimeCaching`. It also precaches the URLs
 * defined in `entries`, so you must NOT precache any of them beforehand.
 *
 * @param options
 * @returns The modified `runtimeCaching` array.
 * @deprecated
 */
export declare const fallbacks: ({ precacheController, router, runtimeCaching, entries, precacheOptions, }: FallbacksOptions) => RuntimeCaching[];
//# sourceMappingURL=fallbacks.d.ts.map